Exercise 1.1
1.
emacs SP exer1.html

2.
C-s HTML
Enter

3.
C-s scavenger
C-r
Enter

4.
C-s self-referential
C-r
Enter

5.
C-s arrow
C-r
Enter

6.
C-e

7.
C-a

8. Already done so as described above.

9. I did not use the arrow key.

10.
C-x C-c

Exercise 1.2
1.
eamcs SP exer2.html

2.
M-g g 18 Enter
C-u 1 C-k

3.
C-s DELETE-ME
Enter
C-a
C-u 1 C-k

4.
C-s HTML_comment
Enter
C-a
C-u 1 C-k

5.
C-s <!
C-r
Enter
C-u 3 C-k
C-s <!--
C-s
C-r
Enter
C-u 4 C-k
C-s <!--
C-r
Enter
C-u 1 C-k

6. Save and exit emacs
C-x C-s
C-x C-c
diff SP -u SP exer1.html SP exer2.html SP > SP exer2.diff

Exercise 1.3
1.
emacs SP exer2.html

2.
M-% Assignment 1 Enter Assignment 51 Enter y y Enter

3.
M-<
M-% UTF-8 Enter US-ASCII Enter y Enter

4.
M-<
C-s </ol> Enter
Enter

5.
C-x C-s
C-x C-c
diff -u exer1.html exer3.html

Exercise 1.4
1.
cat SP exer2.html SP exer2.diff SP > SP exer4.html

2.
emacs exer4.html

3. 4.
C-s <!-- diff C-r ENTER
C-k
M-g g 18 ENTER
C-y ENTER
C-s <!-- DELETE-ME C-r ENTER
C-k
M-g g 114 ENTER
C-y ENTER
C-s <!-- You C-r ENTER
BACKSPACE
C-n C-d
C-n C-d
C-r <!- ENTER
C-u 3 C-k
M-g g 324 ENTER
C-y
C-s #Comments ENTER
C-a
C-f
C-k
M-g g 175 ENTER
C-y
ENTER
C-s -<!-- C-r ENTER
C-d C-n C-d C-n C-d C-n C-d
C-r <!-- ENTER
C-u 4 C-k
M-g g 362 ENTER
C-y
C-s -<! ENTER
C-a C-f C-k
M-g g 380 ENTER
C-y ENTER

5.
C-@
M->
C-w

6.
C-x u

7.
<!-- ENTER
M->
-->

8.
M-x replace-string ENTER <ol> ENTER <oL> ENTER

9.
diff SP -u SP exer1.html SP exer4.html SP > SP exer4.html


Exercise 1.5
1.
emacs ENTER
M-x make-directory ENTER junk ENTER

2.
C-x C-f junk/hello.c ENTER

3.
M-x compile ENTER
C-a
C-k
gcc SP -o SP hello.out SP hello.c ENTER

4.
C-x b hello-out ENTER
C-u M-! ./hello.out
M-x append-to-buffer ENTER key1.txt ENTER
#include <stdio.h>
int
main (void)
{
  char n = '\n';
  char b = '\\';
  char q = '"';
  char const *p = "#include <stdio.h>%cint%cmain (void)%c{%c  char n = '%cn';%c  char b = '%c%c';%c  char q = '%c';%c  char const *p = %c%s%c;%c  printf (p, n, n, n, n, b, n, b, b, n, q, n, q, p, q, n, n, n, n);%c  return 0;%c}%c";
  printf (p, n, n, n, n, b, n, b, b, n, q, n, q, p, q, n, n, n, n);
  return 0;
}


Exercise 1.6: Running Elisp code
1.
emacs ENTER
C-x b ENTER

2.
(random)
C-j

3.
(setq SP x SP (random))
C-j
(setq SP y SP (random))
C-j

4.
(- SP x SP y)
C-j

We have x = 1494514784434596054 and y = -1599567996052938776.
However, we get x - y = -1517603237939853074, which is incorrect.

5.
M-: (- x y) ENTER
We get the same result from such evaluation and it is still incorrect.

6.
The number generated by the random function is by far not random.
Without discussing all the math involved, what we can observe is that the
random number generated is within certain bounds, most likely resulting from
the internal representation of integer in computer. Besides, the random numbers
generated are all very large in terms of absolute value, suggesting that the
function is not really randomly generating number.

7.
Here we assume that the random function is randomly generating a number between
'most-negative-fixnum' and 'most-positive-fixnum', inclusive. To have the result
mathematically incorrect, we must have an overflow. It follows that the overall
probability can be calculated as (described in Python):

tot_probability = 0
max = most-positive-fixnum
min = most-negative-fixnum
T = max - min
for i in range(min, max + 1):
    tot_probability += abs(x)*(1 - abs(x)) / T

With some algebra, we can simplify the expression to
1/(T^2) * (1 + max + max * (max + 1))
which evaluates to 1/4.
